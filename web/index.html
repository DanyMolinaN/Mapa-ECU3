<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Ecuador 3D - Selección y Previsualización</title>

  <!-- Cesium -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.132/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.132/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />

  <style>
    html,body,#cesiumContainer { width:100%;height:100%;margin:0;padding:0; }
    #controls {
      position:absolute; top:12px; left:12px; z-index:999;
      background: rgba(20,20,20,0.88); padding:12px; border-radius:10px; color:#fff;
      font-family: "Segoe UI", Roboto, Arial, sans-serif; min-width:220px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    #controls h3 { margin:0 0 8px 0; font-size:14px; color:#ffd580; }
    .btn { display:block; width:100%; margin:6px 0; padding:8px 10px; border-radius:6px; border:none; cursor:pointer; font-weight:600; }
    .btn-start { background: linear-gradient(90deg,#2ecc71,#27ae60); color:#012; }
    .btn-cancel { background: linear-gradient(90deg,#e74c3c,#c0392b); color:#fff; }
    .btn-export { background: linear-gradient(90deg,#ff9800,#f57c00); color:#fff; }
    #status { margin-top:8px; font-size:12px; color:#fff; opacity:0.95; }
    #hint { display:block; margin-top:6px; color:#ddd; font-size:11px; }

    #previewContainer {
      position:absolute; bottom:12px; right:12px; width:420px; height:300px; z-index:1000;
      background:#fff; border-radius:8px; overflow:hidden; box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      display:none;
    }
    #previewHeader { height:36px; background:#222; color:#fff; display:flex; align-items:center; justify-content:space-between; padding:0 8px; font-size:13px; }
    #preview3D { width:100%; height:calc(100% - 36px); background:#000; }
    @media (max-width:500px){ #previewContainer{ width:320px; height:240px; } }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <div id="controls">
    <h3>Ecuador 3D — Herramientas</h3>
    <button id="startSelect" class="btn btn-start">Iniciar selección (2 clicks)</button>
    <button id="cancelSelect" class="btn btn-cancel">Cancelar selección</button>
    <button id="export3D" class="btn btn-export">Exportar seleccionado a 3D</button>
    <div id="status">Estado: listo</div>
    <small id="hint">Sugerencia: acércate y selecciona una zona pequeña para mejor detalle.</small>
  </div>

  <div id="previewContainer">
    <div id="previewHeader">
      <div>Previsualización 3D</div>
      <div><button id="previewClose" style="background:none;border:none;color:#fff;cursor:pointer;">✕</button></div>
    </div>
    <div id="preview3D"></div>
  </div>

<script>
  const API_BASE = "http://127.0.0.1:5000"; // ajustar si el servidor está en otra dirección
  Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzYjdlMWY1NS03YTUwLTQ5YzMtYmFmMS0wMzIwYTg4NTA5ZGQiLCJpZCI6MzMwNDI2LCJpYXQiOjE3NTQ3ODkwODN9.-iv3OiABUa6h8PSKNalIaQVuvgojUGADVHbPd7qO4wo";

  let previewViewer = null;
  let previewModelEntity = null;

  async function init() {
    // Crear el viewer principal (con terreno)
    const viewer = new Cesium.Viewer('cesiumContainer', {
      imageryProvider: new Cesium.OpenStreetMapImageryProvider(),
      terrainProvider: await Cesium.createWorldTerrainAsync(),
      baseLayerPicker: true, geocoder: false, homeButton: true, sceneModePicker: true,
      timeline: false, animation: false
    });

    viewer.scene.globe.enableLighting = true;
    viewer.scene.globe.depthTestAgainstTerrain = true;

    const statusDiv = document.getElementById('status');

    // Vista inicial - Ecuador
    viewer.camera.flyTo({
      destination: Cesium.Rectangle.fromDegrees(-92, -5, -74, 2),
      orientation: { heading: Cesium.Math.toRadians(0), pitch: Cesium.Math.toRadians(-45), roll: 0 },
      duration: 1.4
    });

    // Cargar GeoJSON de provincias robustamente y dibujar contornos mediante polylines
    const geojsonUrl = `${API_BASE}/data/geoBoundaries-ECU-ADM2_simplified.geojson`;
    Cesium.GeoJsonDataSource.load(geojsonUrl, { clampToGround: true })
      .then(ds => {
        viewer.dataSources.add(ds);

        // Para evitar tocar propiedades internas inválidas, generamos polylines desde el geojson
        ds.entities.values.forEach(entity => {
          // hacemos fill transparente para polígonos
          if (entity.polygon) {
            entity.polygon.material = Cesium.Color.TRANSPARENT;
            entity.polygon.outline = false;
          }
          // si hay polyline en GeoJSON, lo estilizamos
          if (entity.polyline) {
            try {
              entity.polyline.width = 2;
              entity.polyline.material = Cesium.Color.BLACK;
              entity.polyline.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(0.0, 1.0e7);
            } catch(e) { /* silenciar si no aplica */ }
          }
        });

        // Además: crear polyline explícita para los polígonos (si la geojson no crea una)
        // NOTA: esto consume algo más de tiempo; si tu geojson ya trae límites, puedes comentar esta parte.
        ds.entities.values.forEach(entity => {
          if (entity.polygon && entity.polygon.hierarchy) {
            const h = entity.polygon.hierarchy.getValue(Cesium.JulianDate.now());
            if (h && h.positions) {
              const pts = h.positions.map(p => {
                const c = Cesium.Cartographic.fromCartesian(p);
                return [Cesium.Math.toDegrees(c.longitude), Cesium.Math.toDegrees(c.latitude)];
              });
              // aplanar array de lon/lat
              const arr = [];
              pts.forEach(p => { arr.push(p[0], p[1]); });
              if (arr.length > 2) {
                viewer.entities.add({
                  polyline: { positions: Cesium.Cartesian3.fromDegreesArray(arr), width: 2, material: Cesium.Color.BLACK, clampToGround: true }
                });
              }
            }
          }
        });

        statusDiv.innerText = "Estado: GeoJSON cargado (divisiones visibles)";
      })
      .catch(err => {
        console.error("Error cargando GeoJSON:", err);
        statusDiv.innerText = "Estado: fallo cargando GeoJSON (ver consola)";
      });

    // --- SELECCIÓN: dos clicks usando pickPosition + fallback pickEllipsoid ---
    let selecting = false;
    let first = null;
    let rectEntity = null;

    function addSelectionRectangle(minLon, minLat, maxLon, maxLat) {
      if (rectEntity) viewer.entities.remove(rectEntity);
      // animación de alpha usando CallbackProperty
      const start = Date.now();
      const material = new Cesium.CallbackProperty(() => {
        const a = 0.22 + 0.18 * Math.sin((Date.now() - start) / 300.0);
        return Cesium.Color.ORANGE.withAlpha(Math.max(0.08, Math.min(0.4, a)));
      }, false);

      rectEntity = viewer.entities.add({
        rectangle: {
          coordinates: Cesium.Rectangle.fromDegrees(minLon, minLat, maxLon, maxLat),
          material: material,
          outline: true,
          outlineColor: Cesium.Color.RED,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
        }
      });
      return rectEntity;
    }

    document.getElementById('startSelect').onclick = () => {
      selecting = true; first = null;
      if (rectEntity) { viewer.entities.remove(rectEntity); rectEntity = null; }
      statusDiv.innerText = "Modo selección activo: haz 2 clicks";
    };
    document.getElementById('cancelSelect').onclick = () => {
      selecting = false; first = null;
      if (rectEntity) { viewer.entities.remove(rectEntity); rectEntity = null; }
      statusDiv.innerText = "Selección cancelada";
    };

    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction(function(click) {
      if (!selecting) return;

      // preferimos pickPosition para obtener la posición real sobre el terreno
      let cartesian = viewer.scene.pickPosition(click.position);
      if (!cartesian || Cesium.defined(cartesian) === false) {
        cartesian = viewer.scene.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
      }
      if (!cartesian) {
        statusDiv.innerText = "Click inválido (fuera del globo/terreno).";
        return;
      }

      const carto = Cesium.Cartographic.fromCartesian(cartesian);
      const lon = Cesium.Math.toDegrees(carto.longitude);
      const lat = Cesium.Math.toDegrees(carto.latitude);

      if (!first) {
        first = { lon, lat };
        statusDiv.innerText = "Primera esquina guardada. Haz el segundo click.";
      } else {
        const minLon = Math.min(first.lon, lon), maxLon = Math.max(first.lon, lon);
        const minLat = Math.min(first.lat, lat), maxLat = Math.max(first.lat, lat);
        addSelectionRectangle(minLon, minLat, maxLon, maxLat);
        selecting = false;
        statusDiv.innerText = `Seleccionado: ${minLon.toFixed(4)},${minLat.toFixed(4)} → ${maxLon.toFixed(4)},${maxLat.toFixed(4)}`;
        viewer.camera.flyTo({ destination: Cesium.Rectangle.fromDegrees(minLon, minLat, maxLon, maxLat), orientation: { pitch: Cesium.Math.toRadians(-55) }, duration: 1.0 });
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // --- EXPORTAR + PREVIEW ---
    document.getElementById('export3D').onclick = async () => {
      if (!rectEntity) { statusDiv.innerText = "No hay selección"; return; }
      const rect = rectEntity.rectangle.coordinates.getValue();
      const sw = Cesium.Rectangle.southwest(rect), ne = Cesium.Rectangle.northeast(rect);
      const minLon = Cesium.Math.toDegrees(sw.longitude), minLat = Cesium.Math.toDegrees(sw.latitude);
      const maxLon = Cesium.Math.toDegrees(ne.longitude), maxLat = Cesium.Math.toDegrees(ne.latitude);

      const polygonFeature = {
        type: "Feature",
        properties: {},
        geometry: {
          type: "Polygon",
          coordinates: [[
            [minLon, minLat],
            [minLon, maxLat],
            [maxLon, maxLat],
            [maxLon, minLat],
            [minLon, minLat]
          ]]
        }
      };

      statusDiv.innerText = "Enviando selección al servidor...";
      try {
        const res = await fetch(`${API_BASE}/api/clip`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ geometry: polygonFeature.geometry })
        });

        const payload = await res.json();
        if (res.status === 200 || res.status === 202) {
          if (payload.glb_url) {
            statusDiv.innerText = "Modelo generado — cargando vista previa...";
            await showPreviewGLB(payload.glb_url, (minLon + maxLon) / 2, (minLat + maxLat) / 2);
          } else if (payload.job_id) {
            statusDiv.innerText = `Trabajo encolado (job ${payload.job_id}). Esperando resultado...`;
            await pollStatusAndShow(payload.job_id, (minLon + maxLon) / 2, (minLat + maxLat) / 2);
          } else if (payload.inter_geojson) {
            Cesium.GeoJsonDataSource.load(payload.inter_geojson, { clampToGround: true }).then(ds => viewer.dataSources.add(ds));
            statusDiv.innerText = "Intersección añadida al mapa.";
          } else {
            statusDiv.innerText = "Respuesta no contiene resultados esperados. Ver consola.";
            console.log("payload:", payload);
          }
        } else {
          statusDiv.innerText = `Error servidor: ${payload.error || JSON.stringify(payload)}`;
        }
      } catch (err) {
        console.error("Error fetch /api/clip:", err);
        statusDiv.innerText = "Error enviando selección (ver consola).";
      }
    };

    async function pollStatusAndShow(jobId, centerLon, centerLat) {
      const url = `${API_BASE}/api/status/${jobId}`;
      for (let i=0;i<90;i++){
        try {
          const r = await fetch(url);
          const j = await r.json();
          if (r.status === 200) {
            if (j.status === "done" && j.glb_url) {
              await showPreviewGLB(j.glb_url, centerLon, centerLat);
              return;
            } else if (j.status === "error") {
              statusDiv.innerText = "Error en procesamiento: " + (j.message || "");
              return;
            } else {
              statusDiv.innerText = `Procesando... intento ${i+1}`;
            }
          } else {
            statusDiv.innerText = `Estado job: ${r.status}`;
          }
        } catch(e) {
          console.error("poll error:", e);
        }
        await new Promise(res => setTimeout(res, 2000));
      }
      statusDiv.innerText = "Tiempo de espera agotado.";
    }

    // Mostrar GLB en preview
    async function showPreviewGLB(glbUrl, lonCenter, latCenter) {
      const previewContainer = document.getElementById('previewContainer');
      previewContainer.style.display = 'block';

      if (!previewViewer) {
        previewViewer = new Cesium.Viewer('preview3D', {
          imageryProvider: new Cesium.OpenStreetMapImageryProvider(),
          terrainProvider: await Cesium.createWorldTerrainAsync(),
          baseLayerPicker: false, geocoder: false, homeButton: false, sceneModePicker: false, timeline: false, animation: false
        });
        previewViewer.scene.globe.depthTestAgainstTerrain = true;
      } else {
        previewViewer.entities.removeAll();
      }

      const pos = Cesium.Cartesian3.fromDegrees(lonCenter, latCenter, 0);
      previewModelEntity = previewViewer.entities.add({
        name: "Preview GLB",
        position: pos,
        model: { uri: glbUrl, scale: 1.0, minimumPixelSize: 64 }
      });

      try {
        await previewModelEntity.model.readyPromise;
        await previewViewer.zoomTo(previewViewer.entities);
        statusDiv.innerText = "Previsualización cargada.";
      } catch (err) {
        console.error("Error cargando GLB en preview:", err);
        statusDiv.innerText = "Error cargando modelo 3D (ver consola).";
        // añadir link para diagnóstico
        const link = document.createElement('a');
        link.href = glbUrl; link.target = "_blank"; link.textContent = "Abrir GLB en nueva pestaña";
        statusDiv.appendChild(document.createElement('br'));
        statusDiv.appendChild(link);
      }
    }

    document.getElementById('previewClose').onclick = () => {
      document.getElementById('previewContainer').style.display = 'none';
      if (previewViewer) previewViewer.entities.removeAll();
    };

  } // init()

  init().catch(err => {
    console.error("Init error:", err);
    document.getElementById('status').innerText = "Error inicializando visor (ver consola).";
  });
</script>
</body>
</html>
